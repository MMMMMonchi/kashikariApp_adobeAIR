////////////////////////////////////////////////////////////////////////友人、自分のアイテムが表示されるページを生成するクラス//////////////////////////////////////////////////////////////////////package ui.page.friendItemPage {	import flash.display.Bitmap;	import flash.display.Sprite;	import common.CreateTextField;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.text.TextField;	import common.CreateTestSprite;	import ui.footer.Footer;	import ui.header.Header;	import  aeon.animators.Tweener;	import aeon.easing.Quint;	import aeon.events.AnimationEvent;	import flash.display.Loader;	import flash.net.URLRequest;	public class FriendItemPage extends Sprite {				private var _backgroundImage:Bitmap;		private var _scrollContainer:Sprite;		private var _footer:Footer;		private var _header:Header;		public function FriendItemPage() {						_footer = _global.footer as Footer;			_header = _global.header as Header;						_global.friendItemPage = this;			//ページ上のコンテンツを生成する			makeContents();		}				//////////////////////////////////////////////////////////////////////		//ページ上のコンテンツを生成するメソッド		//////////////////////////////////////////////////////////////////////				private var _itemNum:int = 10;		private var _scrollContainerStartPositionY:int = 100 + 20;		private var _itemList:Array;		private var _leftItemPositionX:int;		private var _rotationCenterPostionX:int = MainContainer.IPHONE_WIDTH / 2;		private var _frontContainerList:Array;		private var _backContainerList:Array;		private function makeContents():void {									//アイテムの幅はデータベースに事前に保存しておき、どちらにスケールするかを判定してから配置する															//アイテムを乗せるコンテナを生成する。			_scrollContainer = new Sprite();						//アイテムを生成する。			var itemWidth:int = (MainContainer.IPHONE_WIDTH - 100) / 2;			var itemHeight:int = 400;			var itemMarginX:int = 10;			var itemMarginY:int = 10;			_leftItemPositionX = MainContainer.IPHONE_WIDTH / 2 - (itemWidth * 2 + itemMarginX) / 2;			var rightItemPostionX:int = _leftItemPositionX + itemWidth + itemMarginX;						//アイテムを格納する配列郡			_itemList = new Array();			_frontContainerList = new Array();			_backContainerList = new Array();						for (var i:int = 0; i < _itemNum; i++) {								//ローテーション用の処理				var leftRotationContainer:Sprite = new Sprite();				leftRotationContainer.x = _rotationCenterPostionX;								//左側のアイテムを乗せるコンテナ				//この上に、表側のコンテナと裏側のコンテナを載せている				//このコンテナにマウスイベントが設定されており、子にはイベントがいかないようになっている				var leftItem:Sprite = new Sprite();				leftItem.x = _leftItemPositionX-_rotationCenterPostionX;				leftItem.y = (itemHeight + itemMarginY) * i;				leftItem.mouseChildren = false;//ここ				leftItem.addEventListener(MouseEvent.CLICK, onMClickLeftItem);								//-----------------------------------------------------------------				//表側のコンテナ　　開始				//-----------------------------------------------------------------								var leftFrontContainer:Sprite=CreateTestSprite.getTestRectangle(0xff00ff, 0, itemWidth, itemHeight);				var testText:TextField = CreateTextField.getNormalTextField(Math.random().toString() + "これ", 25);				var loader:Loader = new Loader();								//ローダを使用して画像を読み込んだ場合プロパティにアクセスできるのはinitイベント送出後				loader.contentLoaderInfo.addEventListener(Event.INIT, function(e:Event):void {					//画像幅を規定のアイテムの幅に固定するために、画像が読み込まれた後に調整する					e.currentTarget.loader.scaleX = e.currentTarget.loader.scaleY = itemWidth / e.currentTarget.loader.width;				});				//暫定で画像を入れる				if (i % 2 == 0) {						loader.load(new URLRequest("http://ec2.images-amazon.com/images/I/718ANNqpEqL._AA1434_.jpg"));				}				else {					loader.load(new URLRequest("http://ec2.images-amazon.com/images/I/51mjA5VNZSL.jpg"));				}				leftFrontContainer.addChild(loader);				leftFrontContainer.addChild(testText);								//左側のコンテナに表側コンテナを追加				leftItem.addChild(leftFrontContainer);				//配列に格納				_frontContainerList.push(leftFrontContainer);								//-----------------------------------------------------------------				//表側のコンテナ　　終了				//-----------------------------------------------------------------								//-----------------------------------------------------------------				//裏側のコンテナ　　開始				//-----------------------------------------------------------------								//裏側のテスト				/*var leftBackContainer:Sprite = CreateTestSprite.getTestRectangle(0xff00ff, 0,itemWidth,itemHeight);				var testText2:TextField = CreateTextField.getNormalTextField(Math.random().toString() + "これ", 25);				testText2.y = 100;				leftBackContainer.addChild(testText2);								//裏側コンテナ全体を反転				leftBackContainer.rotationY = 180;				//座標に気をつける(反転後の位置になる)				leftBackContainer.x = leftBackContainer.width + itemWidth;				//左側のコンテナに裏側のコンテナを追加				leftItem.addChild(leftBackContainer);				//配列に格納				_backContainerList.push(leftBackContainer);*/								//-----------------------------------------------------------------				//裏側のコンテナ　　終了				//-----------------------------------------------------------------								//回転に使うコンテナに左側のアイテムを追加する				leftRotationContainer.addChild(leftItem);								//表側コンテナを最上面に配置しなおす				//leftItem.setChildIndex(leftFrontContainer, numChildren + 1);								//-----------------------------------------------------------------				//右側のコンテナ　　開始				//-----------------------------------------------------------------								var rightRotatinConatiner:Sprite = new Sprite();				rightRotatinConatiner.x = _rotationCenterPostionX;								var rightItem:Sprite = CreateTestSprite.getTestRectangle(0x00ff00, 0.5, itemWidth, itemHeight);				rightItem.x = rightItemPostionX-_rotationCenterPostionX;				rightItem.y = (itemHeight+ itemMarginY) * i;								rightRotatinConatiner.addChild(rightItem);								//-----------------------------------------------------------------				//右側のコンテナ　　終了				//-----------------------------------------------------------------								//スクロールのコンテナに左右の回転コンテナを追加				_scrollContainer.addChild(leftRotationContainer);				_scrollContainer.addChild(rightRotatinConatiner);			}						//スクロールのコンテナのｙ座標を調整する			_scrollContainer.y = _scrollContainerStartPositionY;			addChild(_scrollContainer);						//スクロールの最大量を設定する			_maxScrollY = _scrollContainer.height+20*2 - (MainContainer.IPHONE_HEIGHT - _header.height - _footer.height);						//スクロール関係のイベントを設定する			_scrollContainer.addEventListener(MouseEvent.MOUSE_DOWN, onMDownScrollContainer);			_scrollContainer.addEventListener(MouseEvent.MOUSE_MOVE, onMMoveScrollContainer);			_scrollContainer.addEventListener(MouseEvent.MOUSE_UP, onMUpScrollContainer);		}				private var _moveValue:int = 0;		private var _prePositionY:int = 0;		private var _mouseDownFlg:Boolean = false;				//////////////////////////////////////////////////////////////////////		//スクロールコンテナをタッチした際のメソッド		//////////////////////////////////////////////////////////////////////				private function onMDownScrollContainer(e:MouseEvent):void {						//移動量は０			_moveValue = 0;						//最初に触った場所のｙ			_prePositionY = e.stageY;						//スクロールアニメーションのイベントを設定			addEventListener(Event.ENTER_FRAME, onEFrameScroll);						//現在タッチしているかどうかのフラグ			_mouseDownFlg = true;		}				//////////////////////////////////////////////////////////////////////		//スクロールコンテナのタッチを離した際のメソッド		//////////////////////////////////////////////////////////////////////				private function onMUpScrollContainer(e:MouseEvent):void {			//現在タッチしているかどうかのフラグ			_mouseDownFlg = false;		}				//////////////////////////////////////////////////////////////////////		//スクロールコンテナ内を動かした際のメソッド		//////////////////////////////////////////////////////////////////////				private function onMMoveScrollContainer(e:MouseEvent):void {			//現在ボタンを押しっぱなしならば			if (e.buttonDown) {				//移動量に移動した分(現在位置と以前の位置の差分)を加える				_moveValue += (e.stageY - _prePositionY) * 2.2;				//移動量の差分を出すのに使う位置を再取得				_prePositionY = e.stageY;			}		}				//////////////////////////////////////////////////////////////////////		//スクロールコンテナを動かすメソッド		//////////////////////////////////////////////////////////////////////				private const SCROLL_VALUE:int = 5;		private var _maxScrollY:int;		private function onEFrameScroll(e:Event):void {						_moveValue += (0 - _moveValue) / 6;						_scrollContainer.y += _moveValue / SCROLL_VALUE ;						//Y位置が初期位置より下に来ないように設定			if (_scrollContainer.y > _scrollContainerStartPositionY) {				_scrollContainer.y = _scrollContainerStartPositionY;			}						//Ｙ位置がスクロール最大幅以上にスクロールしないように設定			else if (_scrollContainer.y < _scrollContainerStartPositionY - _maxScrollY) {				_scrollContainer.y = _scrollContainerStartPositionY- _maxScrollY;			}						//画面にタッチしておらず、なおかつ移動量が0に近い場合には、エンターフレームイベントを停止させる。			if (_mouseDownFlg == false && Math.abs(_moveValue) < 1.5) {				removeEventListener(Event.ENTER_FRAME, onEFrameScroll);			}			_scrollContainer.scaleX		}				private const SCALL_ITEM_WIDTH:int =550;		private const SCALL_ITEM_HEIGHT:int = 710;		private const SCALL_ANIMATION_TIME:int = 1000;				//////////////////////////////////////////////////////////////////////		//左側のコンテナをタッチした際のメソッド(タッチした際のアニメーションを生成する)		//////////////////////////////////////////////////////////////////////				private function onMClickLeftItem(e:MouseEvent):void {						//タッチしたアイテムが何番目かのインデックス番号			var identifier:int = _scrollContainer.getChildIndex(e.target.parent)/2;						//イベントを外す			e.target.removeEventListener(MouseEvent.CLICK, onMClickLeftItem);						//選択されたアイテムを一番前の階層にする			_scrollContainer.setChildIndex(e.target.parent, _scrollContainer.numChildren-1);						//アニメーション前のパラメータを取得しておく			var preChildIndex:int = _scrollContainer.getChildIndex(e.target.parent);			var preItemPositionX:int = e.target.x;			var preItemPositionY:int = e.target.y;			var preItemScaleY:int = e.target.scaleY;			var preItemScaleX:int = e.target.scaleX;			var preItemRotaionY:int = e.target.parent.rotationY;						//拡大するアニメーションを生成する			var tweener1:Tweener = new Tweener(e.target, { y:Tweener.CURRENT_VALUE }, { y:_scrollContainerStartPositionY-_scrollContainer.y},SCALL_ANIMATION_TIME, Quint.easeOut);			var tweener2:Tweener = new Tweener(e.target, { x:Tweener.CURRENT_VALUE }, { x:_leftItemPositionX-_rotationCenterPostionX},SCALL_ANIMATION_TIME, Quint.easeOut);			var tweener3:Tweener = new Tweener(e.target, { scaleY:Tweener.CURRENT_VALUE }, { scaleY:SCALL_ITEM_HEIGHT/e.target.height},SCALL_ANIMATION_TIME, Quint.easeOut);			var tweener4:Tweener = new Tweener(e.target, { scaleX:Tweener.CURRENT_VALUE }, { scaleX:SCALL_ITEM_WIDTH/e.target.width },SCALL_ANIMATION_TIME, Quint.easeOut);			tweener1.start();			tweener2.start();			tweener3.start();			tweener4.start();			//拡大アニメーションが生成されたタイミングで実行するメソッドを設定			tweener4.addEventListener(AnimationEvent.END, function (ea1:AnimationEvent):void {								//裏側のコンテナを最前面にもってくる				//e.target.setChildIndex(_backContainerList[identifier], e.target.numChildren-1);				//回転するアニメーションを生成する				var tweener5:Tweener=new Tweener(e.target.parent,{ rotationY:Tweener.CURRENT_VALUE }, { rotationY:180},SCALL_ANIMATION_TIME, Quint.easeOut);				tweener5.start();				//回転するアニメーションが終了したタイミングで実行されるメソッドを設定				tweener5.addEventListener(AnimationEvent.END, function (ea2:AnimationEvent):void {					//元の位置に戻るクリックイベントを設定する					e.target.addEventListener(MouseEvent.CLICK, function back(me:MouseEvent):void {												//戻るイベントを外す						e.target.removeEventListener(MouseEvent.CLICK, back);												//戻るアニメーションを生成する。						var tweener6:Tweener = new Tweener(e.target.parent, { rotationY:Tweener.CURRENT_VALUE }, { rotationY:preItemRotaionY }, SCALL_ANIMATION_TIME, Quint.easeOut);						var tweener7:Tweener = new Tweener(e.target, { y:Tweener.CURRENT_VALUE }, { y:preItemPositionY},SCALL_ANIMATION_TIME, Quint.easeOut);						var tweener8:Tweener = new Tweener(e.target, { x:Tweener.CURRENT_VALUE }, { x:preItemPositionX},SCALL_ANIMATION_TIME, Quint.easeOut);						var tweener9:Tweener = new Tweener(e.target, { scaleY:Tweener.CURRENT_VALUE }, { scaleY:preItemScaleY},SCALL_ANIMATION_TIME, Quint.easeOut);						var tweener10:Tweener = new Tweener(e.target, { scaleX:Tweener.CURRENT_VALUE }, { scaleX:preItemScaleX },SCALL_ANIMATION_TIME, Quint.easeOut);						tweener6.start();						tweener7.start();						tweener8.start();						tweener9.start();						tweener10.start();						//戻るアニメーションが生成された後のメソッドを設定する						tweener10.addEventListener(AnimationEvent.END, function (ea3:AnimationEvent):void {							//戻るアニメーションを行っていたイベントを外す							e.target.addEventListener(MouseEvent.CLICK, onMClickLeftItem);						});					});				});			});		}				private function scallAnimationEnd(e:AnimationEvent):void {					}	}}